1)/*
Input
The first line contains an integer n (1 ≤ n ≤ 3 ∗ 103).
The second line contains a string of length n consisting of only lowercase English alphabet.
Your solution should run in O(n2) time complexity
Output
The length of the longest substring which is also a palindrome.
*/
#include <stdio.h>

int longestPalSubstr(char *str,int n)
{
    int maxLength = 1, start = 0;
    int table[n][n];

    for (int i = 0; i < n; ++i)
        for(int j=0;j<n;j++)
            table[i][j] =(i==j)?1:0;

    for (int i = 0; i < n - 1; ++i)
    {
        if (str[i] == str[i + 1])
        {
            table[i][i + 1] = 1;
            start = i;
            maxLength = 2;
        }
    }

    for (int k = 3; k <= n; ++k)
    {
        for (int i = 0; i < n - k + 1; ++i)
        {
            int j = i + k - 1;
            if (table[i + 1][j - 1] && str[i] == str[j])
            {
                table[i][j] = 1;
                if (k > maxLength)
                {
                    start = i;
                    maxLength = k;
                }
            }
        }
    }
    return maxLength;
}

int main() {
    int n;
    scanf("%d", &n);
    char str[n];
    scanf("%s", str);
    printf("%d\n", longestPalSubstr(str,n));
    return 0;
}

2)/*
Input
The first line contains an integer n (1 ≤ n ≤ 105).
The second line contains a string of length n consisting of only lowercase English alphabet.
Your solution should run in O(n) time complexity.
Output
The maximum number of consecutive alphabets without repetition.
*/
#include <stdio.h>

int longestUniqueSubstr(char* str,int n)
{
    int cur_len = 1; // length of current part of string
    int max_len = 1; // result
    int prev_index;  // previous index
    int visited[3000];

    for (int i = 0; i < 3000; i++)
        visited[i] = -1;
    
    visited[str[0]] = 0;

    for (int i = 1; i < n; i++)
    {
        prev_index = visited[str[i]];

        if (prev_index == -1 || i - cur_len > prev_index)
            cur_len++;
        else
        {
            if (cur_len > max_len)
                max_len = cur_len;

            cur_len = i - prev_index;
        }

        visited[str[i]] = i;
    }

    if (cur_len > max_len)
        max_len = cur_len;

    return max_len;
}

int main() {
    int n;
    scanf("%d",&n);
    char str[n];
    scanf("%s", str);
    printf("%d",longestUniqueSubstr(str,n));
    return 0;
}
3)/*
Input
The first line contains an integer n (1 ≤ n ≤ 105).
The second line contains a string of length n consisting of only lowercase English alphabet and
whitespace.
Your solution should run in O(n) time complexity.
Output
A string of length n ,where every word is reversed.
*/
#include <stdio.h>
//This uses two pointer approach
void reverse(char* begin, char* end) {
    char temp;
    while (begin < end) {
        temp = *begin;
        *begin++ = *end;
        *end-- = temp;
    }
}

void reverseWords(char* s) {
    char* word_begin = s;
    char* temp = s;

    while (*temp) {
        temp++;
        if (*temp == '\0') {
            reverse(word_begin, temp - 1);
        } else if (*temp == ' ') {
            reverse(word_begin, temp - 1);
            word_begin = temp + 1;
        }
    }
}

int main() {
    int n;
    scanf("%d",&n);
    char s[n];
    scanf(" %[^\n]", s);
    reverseWords(s);
    printf("%s", s);
    return 0;
}
4)/*
Input
The first line contains an integer n (1 ≤ n ≤ 105).
The second line contains a string of length n consisting of only lowercase English alphabet and
whitespace.
Your solution should run in O(n) time complexity.
Bonus: Can you solve it using only constant extra space?
Output
A string whose order of vowels are reversed.
*/
#include<stdio.h>
int main()
{
    int n,j=0;
    scanf("%d",&n);
    char str[n],b[n];
    scanf(" %[^\n]",str);
    int num[n];
    for(int i=0;i<n;i++)
    {
        if(str[i]=='a' || str[i]=='e' || str[i]=='i' || str[i]=='o' || str[i]=='u')
        { 
            num[i]=-1;
            b[j++]=str[i];
        }
    }
    for(int i=0;i<n;i++)
    {
        if(num[i]==-1)
        printf("%c",b[(j--)-1]);
        else
        printf("%c",str[i]);
    }
}

5)/*
Input
The first line contains two integers n and m (1 ≤ n, m ≤ 105).
The second line contains n integers of the first array (1 ≤ a1 ≤ a2 ... ≤ an−1 ≤ an ≤ 109).
The third line contains n integers of the second array (1 ≤ b1 ≤ b2 ... ≤ bn−1 ≤ bn ≤ 109).
Your solution should run in O(n+m) time complexity.
Output
array with merged elements in sorted order.
*/
#include<stdio.h>
void mergeArrays(int a[], int b[], int n, int m)
{
    int i = 0, j = 0, k = 0;

    while (i<n && j <m) {
        if (a[i] < b[j])
            printf("%d ",a[i++]);
        else
            printf("%d ",b[j++]);
    }

    while (i < n)
        printf("%d ",a[i++]);

    while (j < m)
        printf("%d ",b[j++]);
}
int main()
{
    int n,m;
    scanf("%d %d",&n,&m);
    int a[n],b[m];
    for(int i=0;i<n;i++)
    scanf("%d",&a[i]);
    for(int i=0;i<m;i++)
    scanf("%d",&b[i]);
    mergeArrays(a,b,n,m);

}

6)/*
Input
The first line contains three integers n, k and x (1 ≤ k ≤ n ≤ 105, 1 ≤ x ≤ 109).
The second line contains n integers which represent the cursed energies of the cursed spirits in
sequence a (−109 ≤ ai ≤ 109).
Your solution should run in O(n) time complexity.
Output
number of groups of k numbers whose average>=x.
*/
#include<stdio.h>
//This uses sliding window
int main() {
    int n, k, x, c = 0;
    scanf("%d %d %d", &n, &k, &x);
    int a[n];
    int sum = 0;
    for(int i = 0; i < n; i++)
        scanf("%d", &a[i]);

    for(int i = 0; i < k; i++)
        sum += a[i];

    for(int i = k; i <= n; i++)
    {
        if(sum >= x * k)
            c++;    
        if(i < n)
            sum = sum - a[i - k] + a[i];
    }
    printf("%d", c);
    return 0;
}

7)/*
Input
First line contains an integer n (1 ≤ n ≤ 105).
Second line contains n integers in an array a (1 ≤ ai ≤ 109).
Your solution should run in O(n) time complexity.
Output
The max sum where both sums are equal
*/
#include <stdio.h>
//This also uses two pointer approach
int maxweight(int n, int a[])
{
    int i = 0, j = n - 1;
    int leftSum = 0, rightSum = 0, maxSum = 0;

    while (i <= j)
    {
        if (leftSum <= rightSum)
            leftSum += a[i++];
        else 
            rightSum += a[j--];
        if (leftSum == rightSum)
            maxSum = leftSum;
    }
    return maxSum;
}

int main()
{
    int n;
    scanf("%d", &n);
    int a[n];
    for (int i = 0; i < n; i++)
        scanf("%d", &a[i]);
    printf("%d", maxweight(n, a));
    return 0;
}

8)

9)/*
Input
First line contains an integer n (1 ≤ n ≤ 105).
Second line contains n positive integers in an array a (1 ≤ ai ≤ 109).
Your solution should run in O(npmax(ai)) time complexity.
Output
The product of all non-primes modulo (10^9+7)
*/
#include <stdio.h>
#include <math.h>

int isPrime(int n)
{
    if (n <= 1) {
        return 0;
    }
    if (n == 2) {
        return 1;
    }
    if (n % 2 == 0) {
        return 0;
    }
    for (int i = 3; i <= sqrt(n); i += 2) {
        if (n % i == 0) {
            return 0;
        }
    }
    return 1;
}

long long productOfNonPrimes(int arr[], int n)
{
    long long modulus=1000000007;
    long long product = 1;
    int hasNonPrime = 0;
    for (int i = 0; i < n; i++) {
        if (!isPrime(arr[i])) {
            product = (product * arr[i]) % modulus;
            hasNonPrime = 1;
        }
    }
    return hasNonPrime ? product : -1;
}

int main() {
    int n;
    scanf("%d", &n);
    int arr[n];
    for (int i = 0; i < n; i++)
        scanf("%d", &arr[i]);

    long long product = productOfNonPrimes(arr, n);
    printf("%lld", product);

    return 0;
} 